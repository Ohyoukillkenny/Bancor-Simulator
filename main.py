from smartToken import *
from customers import *
# from market import *
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
fw = open('Figures/Transaction-Record.txt','w')


# issue a new smart token
initIssue = 3000000
CRR = 0.2
initTransaction = initIssue * (1-CRR)
KennyCoin = Smartcoin(name='Kenny',reservetokenName='ETH',initCRR=0.2, initPrice=1, initIssueNum=initIssue)

# market initialization
# BancorMarket = Market()

'''
init properties: 
We have #TimeRound round, bouncing happens after every bouncing interval
Totally #custNum  customers come in
In each time round, #tx_round transactions, 
   with original reserve: #custOriginalReserve
   with original smarttokens: #custOriginalSmartTokens
'''
TimeRound = 10000
bouncingInterval = 50
bouncingRange = 10
tx_round = 100
custNum = 5000
sigma = 0.1
custOriginalReserve_mu = 200
custOriginalSmartTokens_mu = 200
custOriginalReserve = np.random.normal(custOriginalReserve_mu, 0.1, custNum) # 0.5 is sigma
custOriginalSmartTokens = np.random.normal(custOriginalSmartTokens_mu, 0.1, custNum) # 0.5 is sigma
'''
prevent the init money exhausts the balance, 
here we already set initIssue SmartToken to 300000000,
which actually is hard to exhaust,
also, we should consider the situation that the init issued smarttokens is comparably small,
      or the init smarttokens is held in customers in a large amount
'''
if sum(custOriginalSmartTokens) > initTransaction:
    print '&& WARNING, too many init smart tokens from customers'
    if sum(custOriginalSmartTokens) > initIssue:
        print '** ERROR, too many init smart tokens'
        turndown = 1 + 'klk'

#custmer initialization, first set all their expected Price to be -1
custlist = []
i = 0
while i < custNum:
    Joe = Customer(smartToken = KennyCoin, 
                   market = BancorMarket,
                   ownedSmartTokens = int(custOriginalSmartTokens[i]), 
                   reserveTokens = int(custOriginalReserve[i]), 
                   expectedPrice = -1)
    custlist.append(Joe)
    i = i + 1
# moneyTracker records the 
moneyTracker = []
# PriceTracker records the change of the price
PriceTracker = []
# failureTracker records the failure rate of transactions
failed_rateTracker = []
waitingTracker = []

# tx_list records the transaction order which remains in the market
tx_list = []
for tick in range(TimeRound):
    buyNum = 0
    sellNum = 0
    CurrentPrice = KennyCoin.getPrice()

    # assign valuations to all users
    if (tick % bouncingInterval == 0):
        # here assume the bouncing_mu is generated by random
        Price_mu = random.uniform(0.1 * market.LastPrice, bouncingRange * market.LastPrice)
    else:
        Price_mu = market.LastPrice

    for customer in custlist:
        customer.changeExpectedPrice(np.random.normal(Price_mu, sigma, CustNum))


            '''
            Here we make an important asumption that customers are willing to finish the transaction,
            as they have already known the current price
            So buyers' expected price should be higher than current price, sellers' should be lower.
            
            In fact we are able to choose buy and sell operation by throwing a coin, 
            but the former situation seems to be more reasonable, 
            and the former market can always perform better than chosing by random. 
            So if we find the former one is flawed, the random's case can only be worse.
            '''
            if custlist[t].getExpectedPrice() >= CurrentPrice:
                # buy
                custReserveToken_Num = custlist[t].getReserveTokens()
                randomBuy = random.randint(0, custReserveToken_Num)
                if custlist[t].getExpectedPrice() >= KennyCoin.getPrice():
                    # cust buy successfully
                    custlist[t].buy(randomBuy)
                    # change expectedPrice for cust, means he could do transaction again
                    custlist[t].changeExpectedPrice(-1)
                    buyNum = buyNum + 1
                else:
                    # failed in buying, add cust to tx list, 1 means to buy
                    tx_list.append((1, custlist[t],randomBuy))
                    # BancorMarket.addBuyer(custlist[t])
            else:
                # sell
                custSmartToken_Num = custlist[t].getownedSmartTokens()
                randomSell = random.randint(0,custSmartToken_Num)            
                if custlist[t].getExpectedPrice() < KennyCoin.getPrice():
                    # cust sells successfully
                    custlist[t].sell(randomSell)
                    # change expectedPrice for cust, means he could do transaction again
                    custlist[t].changeExpectedPrice(-1)
                    sellNum = sellNum + 1
                else:
                    # failed in selling, add cust to tx list, -1 means to sell
                    tx_list.append((-1, custlist[t],randomSell))
                    # BancorMarket.addSeller(custlist[t])
        i = i + 1
    # here we shuffle the cust list to let all customer to get oppotunity to make transactions
    random.shuffle(custlist)

    moneyBalance_all = 0
    for Joe in custlist:
        moneyBalance_all += Joe.getmoneyBalance()

    moneyTracker.append((moneyBalance_all,tick))
    failed_rateTracker.append((len(tx_list)/float(waitingTx_Num_Old+tx_round),tick))
    waitingTracker.append((len(tx_list),tick))
    PriceTracker.append((KennyCoin.getPrice(),tick))

    print 'The',trick,'round:', buyNum, 'buy tx |', sellNum, 'sell tx |', len(tx_list), 'unfinished tx.'
    fw.write('The '+str(j)+' round: '+str(buyNum)+' buy tx | '+str(sellNum)+' sell tx | '+str(len(tx_list))+' unfinished tx.\n')
    j = j + 1

# draw failure rate
j = 0
failedRate = []
myX_FR = []
while j < TimeRound:
    myX_FR.append(j)
    failedRate.append(failed_rateTracker[j][0])
    j = j + 1
x_FR = np.asarray(myX_FR)
y_FR = np.asarray(failedRate)
plt.plot(x_FR,y_FR,'o-',color = 'navy',alpha = 0.8)
plt.title('Failure Rate Change For All Rounds',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Failure Rate of Transaction', fontsize = 15)
plt.savefig('Figures/FailureRate.png', bbox_inches='tight')
plt.close()

# draw waiting list change
j = 0
waitingNum = []
myX_W = []
while j < TimeRound:
    myX_W.append(j)
    waitingNum.append(waitingTracker[j][0])
    j = j + 1
x_W = np.asarray(myX_W)
y_W = np.asarray(waitingNum)
plt.plot(x_W,y_W,'o-',color = 'navy',alpha = 0.8)
plt.title('Unfinished Transactions Num For All Rounds',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Unfinished Transactions Num', fontsize = 15)
plt.savefig('Figures/WaitingNum.png', bbox_inches='tight')
plt.close()

# draw price change figure
j = 0
PriceAllRound = []
myX_P = []
while j < TimeRound:
    PriceAllRound.append(PriceTracker[j][0])
    myX_P.append(j)
    j = j + 1
x_P = np.asarray(myX_P)
y_P = np.asarray(PriceAllRound)
plt.plot(x_P, y_P, 'o-',color = 'navy', alpha = 0.8)
plt.title('Price Change For All Round',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Price of Smart Token', fontsize = 15)
plt.savefig('Figures/Price_Change.png', bbox_inches='tight')
plt.close()

# draw money change figure
j = 0
moneyChange = []
myX_M = []
while j < TimeRound:
    moneyChange.append(moneyTracker[j][0])
    myX_M.append(j)
    j = j + 1
x_M = np.asarray(myX_M)
y_M = np.asarray(moneyChange)
plt.plot(x_M, y_M, 'o-', color = 'navy', alpha = 0.8)
plt.title('Money Balance Change For All Round',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Money Balance of All Custs', fontsize = 15)
plt.savefig('Figures/MoneyBalance_Change.png', bbox_inches='tight')
plt.close()
