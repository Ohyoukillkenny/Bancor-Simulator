from smartToken import *
from customers import *
from market import *
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
fw = open('Transaction-Record.txt','w')


# issue a new smart token
initIssue = 300000000
CRR = 0.2
initTransaction = initIssue * (1-CRR)
KennyCoin = Smartcoin(name='Kenny',reservetokenName='ETH',initCRR=0.2, initPrice=1, initIssueNum=initIssue)

# market initialization
# BancorMarket = Market()

'''
init properties: 
We have #TimeRound round, bouncing happens after every bouncing interval
Totally #custNum  customers come in
In each time round, #tx_round transactions, 
   with original reserve: #custOriginalReserve
   with original smarttokens: #custOriginalSmartTokens
'''
TimeRound = 10000
bouncingInterval = 100
tx_round = 100
custNum = 100000
sigma = 0.1
custOriginalReserve_mu = 200
custOriginalSmartTokens_mu = 200
custOriginalReserve = np.random.normal(custOriginalReserve_mu, 0.1, custNum) # 0.5 is sigma
custOriginalSmartTokens = np.random.normal(custOriginalSmartTokens_mu, 0.1, custNum) # 0.5 is sigma
'''
prevent the init money exhausts the balance, 
here we already set initIssue SmartToken to 300000000,
which actually is hard to exhaust,
also, we should consider the situation that the init issued smarttokens is comparably small,
      or the init smarttokens is held in customers in a large amount
'''
if sum(custOriginalSmartTokens) > initTransaction:
    print '&& WARNING, too many init smart tokens from customers'
    if sum(custOriginalSmartTokens) > initIssue:
        print '** ERROR, too many init smart tokens'
        turndown = 1 + 'klk'

#custmer initialization, first set all their expected Price to be -1
custlist = []
i = 0
while i < custNum:
    Joe = Customers(smartToken = KennyCoin, ownedSmartTokens = int(custOriginalSmartTokens[i]), reserveTokens = int(custOriginalReserve[i]), expectedPrice = -1)
    custlist.append(Joe)
    i = i + 1
# moneyTracker records the 
moneyTracker = []
# PriceTracker records the change of the price
PriceTracker = []
# failureTracker records the failure rate of transactions
failed_rateTracker = []

# tx_list records the transaction order which remains in the market
tx_list = []
j=0
while j < TimeRound:
    buyNum = 0
    sellNum = 0
    CurrentPrice = KennyCoin.getPrice()
    '''
    scan the tx_list, follow the order to try transactions one by one, 
    if succeed, remove the tx element.
    P.S. the element in tx_list is (MARK, cust, tokenNum), 
         when MARK is 1, the cust tries to buy, when MARK is -1, cust tries to sell
    '''
    s = 0
    while s < len(tx_list):
        tx_mark = tx_list[s][0]
        tx_cust = tx_list[s][1]
        tx_tokenNum = tx_list[s][2]
        if tx_mark == - 1:
            # try sell
            if tx_cust.getExpectedPrice() < KennyCoin.getPrice():
                # cust sells successfully
                tx_cust.sell(tx_tokenNum)
                # change expectedPrice, means could do transaction again
                tx_cust.changeExpectedPrice(-1)
                sellNum = sellNum + 1
                tx_list.pop(s)
                s = s - 1
        else:
            # try buy
            if tx_cust.getExpectedPrice() >= KennyCoin.getPrice():
                # cust buys successfully
                tx_cust.buy(tx_tokenNum)
                # change expectedPrice, means could do transaction again
                tx_cust.changeExpectedPrice(-1)
                buyNum = buyNum + 1
                tx_list.pop(s)
                s = s - 1
        s = s + 1

    flag = 0
    if (j > 0) and (j % bouncingInterval == 0):
        # here assume the bouncing_mu is generated by random
        Price_mu = random.uniform(0.1 * CurrentPrice, 1.9 * CurrentPrice)
        # when Price_mu < than currentPrice, every one wants to sell, else every one wants to buy
        if Price_mu < CurrentPrice:
            flag = -1 # sell
        else:
            flag = 1 # buy
    else:
        Price_mu = CurrentPrice

    custExpectedPrice = np.random.normal(Price_mu, sigma, tx_round)
    i = 0
    for t in xrange(0,custNum):
        if i >= tx_round:
            break
        if custlist[t].getExpectedPrice() >= 0:
            continue
        if custExpectedPrice[i] > 0:
            # avoid newExpectedPrice <= 0
            # in fact newExpectedPrice should not be 0, otherwise will be dead buyer
            newExpectedPrice = custExpectedPrice[i]
        else:
            newExpectedPrice = 0.00001 * KennyCoin.getPrice()

        custlist[t].changeExpectedPrice(newExpectedPrice)
        if flag == -1:
            custSmartToken_Num = custlist[t].getownedSmartTokens()
            randomSell = random.randint(0,custSmartToken_Num)            
            if custlist[t].getExpectedPrice() < KennyCoin.getPrice():
                # cust sells successfully
                custlist[t].sell(randomSell)
                # change expectedPrice, means could do transaction again
                custlist[t].changeExpectedPrice(-1)
                sellNum = sellNum + 1
            else:
                # failed in selling, add cust to tx list, -1 means to sell
                tx_list.append((-1, custlist[t],randomSell))
                # BancorMarket.addSeller(custlist[t])

        elif flag == 1:
            custReserveToken_Num = custlist[t].getReserveTokens()
            randomBuy = random.randint(0, custReserveToken_Num)
            if custlist[t].getExpectedPrice() >= KennyCoin.getPrice():
                # cust buys successfully
                custlist[t].buy(randomBuy)
                custlist[t].changeExpectedPrice(-1)
                buyNum = buyNum + 1
            else:
                # failed in buying, add cust to tx list, 1 means to buy
                tx_list.append((1, custlist[t],randomBuy))
                # BancorMarket.addBuyer(custlist[t])

        else:
            '''
            Here we make an important asumption that customers are willing to finish the transaction,
            as they have already known the current price
            So buyers' expected price should be higher than current price, sellers' should be lower.
            
            In fact we are able to choose buy and sell operation by throwing a coin, 
            but the former situation seems to be more reasonable, 
            and the former market can always perform better than chosing by random. 
            So if we find the former one is flawed, the random's case can only be worse.
            '''
            if custlist[t].getExpectedPrice() >= CurrentPrice:
                # buy
                custReserveToken_Num = custlist[t].getReserveTokens()
                randomBuy = random.randint(0, custReserveToken_Num)
                if custlist[t].getExpectedPrice() >= KennyCoin.getPrice():
                    # cust buy successfully
                    custlist[t].buy(randomBuy)
                    # change expectedPrice for cust, means he could do transaction again
                    custlist[t].changeExpectedPrice(-1)
                    buyNum = buyNum + 1
                else:
                    # failed in buying, add cust to tx list, 1 means to buy
                    tx_list.append((1, custlist[t],randomBuy))
                    # BancorMarket.addBuyer(custlist[t])
            else:
                # sell
                custSmartToken_Num = custlist[t].getownedSmartTokens()
                randomSell = random.randint(0,custSmartToken_Num)            
                if custlist[t].getExpectedPrice() < KennyCoin.getPrice():
                    # cust sells successfully
                    custlist[t].sell(randomSell)
                    # change expectedPrice for cust, means he could do transaction again
                    custlist[t].changeExpectedPrice(-1)
                    sellNum = sellNum + 1
                else:
                    # failed in selling, add cust to tx list, -1 means to sell
                    tx_list.append((-1, custlist[t],randomSell))
                    # BancorMarket.addSeller(custlist[t])
        i = i + 1
    # here we shuffle the cust list to let all customer to get oppotunity to make transactions
    random.shuffle(custlist)
    moneyBalance_all = 0
    for Joe in custlist:
        moneyBalance_all = moneyBalance_all + Joe.getmoneyBalance()

    moneyTracker.append((moneyBalance_all,j))
    failed_rateTracker.append((len(tx_list) / float(TimeRound * tx_round),j))
    PriceTracker.append((KennyCoin.getPrice(),j))

    print 'The',j,'round:', buyNum, 'buy tx |', sellNum, 'sell tx |', len(tx_list), 'unfinished tx.'
    fw.write('After Round '+ str(j) + '\n')
    KennyCoin.saveInfo(fw)
    j = j + 1

# draw failure rate
j = 0
failedRate = []
myX_FR = []
while j < TimeRound:
    myX_FR.append(j)
    failedRate.append(failed_rateTracker[j][0])
    j = j + 1
x_FR = np.asarray(myX_FR)
y_FR = np.asarray(failedRate)
plt.plot(x_FR,y_FR,'o-',color = 'navy',alpha = 0.8)
plt.title('Failure Rate Change For All Rounds',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Failure Rate of Transaction', fontsize = 15)
plt.savefig('FailureRate.png', bbox_inches='tight')
plt.close()

# draw price change figure
j = 0
PriceAllRound = []
myX_P = []
while j < TimeRound:
    PriceAllRound.append(PriceTracker[j][0])
    myX_P.append(j)
    j = j + 1
x_P = np.asarray(myX_P)
y_P = np.asarray(PriceAllRound)
plt.plot(x_P, y_P, 'o-',color = 'navy', alpha = 0.8)
plt.title('Price Change For All Round',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Price of Smart Token', fontsize = 15)
plt.savefig('Price_Change.png', bbox_inches='tight')
plt.close()

# draw money change figure
j = 0
moneyChange = []
myX_M = []
while j < TimeRound:
    moneyChange.append(moneyTracker[j][0])
    myX_M.append(j)
    j = j + 1
x_M = np.asarray(myX_M)
y_M = np.asarray(moneyChange)
plt.plot(x_M, y_M, 'o-', color = 'navy', alpha = 0.8)
plt.title('Money Balance Change For All Round',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Money Balance of All Custs', fontsize = 15)
plt.savefig('MoneyBalance_Change.png', bbox_inches='tight')
plt.close()