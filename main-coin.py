from smartToken import *
from customers import *
from market import *
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
fw = open('Figures/Coin-Transaction-Record.txt','w')


'''
here the case is the customers are just sell or buy in random -- throwing a coin to decide sell or buy,
while ignoring the current price might be lower than expected sell price, or higher than expected buy price
'''
# issue a new smart token
initIssue = 3000000
CRR = 0.2
initTransaction = initIssue * (1-CRR)
KennyCoin = Smartcoin(name='Kenny',reservetokenName='ETH',initCRR=0.2, initPrice=1,initIssueNum=initIssue)

# market initialization
# BancorMarket = Market()

'''
init properties: 
We have #TimeRound round, bouncing happens after every bouncing interval
Totally #custNum  customers come in
In each time round, #tx_round transactions, 
   with original reserve: #custOriginalReserve
   with original smarttokens: #custOriginalSmartTokens
'''
TimeRound = 1000
bouncingInterval = 200
bouncingRange = 1.9
tx_round = 100
custNum = 5000
sigma = 0.1
custOriginalReserve_mu = 200
custOriginalSmartTokens_mu = 200
custOriginalReserve = np.random.normal(custOriginalReserve_mu, 0.1, custNum) # 0.5 is sigma
custOriginalSmartTokens = np.random.normal(custOriginalSmartTokens_mu, 0.1, custNum) # 0.5 is sigma
'''
prevent the init money exhausts the balance, 
here we already set initIssue SmartToken to a large number,
which actually is hard to be exhausted,
also, we should consider the situation that the init issued smarttokens is comparably small,
      or the init smarttokens is held in customers in a large amount
'''
if sum(custOriginalSmartTokens) > initTransaction:
    print '&& WARNING, too many init smart tokens from customers'
    if sum(custOriginalSmartTokens) > initIssue:
        print '** ERROR, too many init smart tokens'
        turndown = 1 + 'klk'

#custmer initialization, first set all their expected Price to be -1
custlist = []
i = 0
while i < custNum:
    Joe = Customers(smartToken = KennyCoin, ownedSmartTokens = int(custOriginalSmartTokens[i]), reserveTokens=int(custOriginalReserve[i]), expectedPrice=-1)
    custlist.append(Joe)
    i = i + 1
# moneyTracker records the money
moneyTracker = []
# PriceTracker records the change of the price
PriceTracker = []
# failureTracker records the failure rate of transactions
failed_rateTracker = []
waitingTracker = []

# tx_list records the transaction order which remains in the market
tx_list = []
j=0
while j < TimeRound:
    buyNum = 0
    sellNum = 0
    CurrentPrice = KennyCoin.getPrice()
    '''
    scan the tx_list, follow the order to try transactions one by one, 
    if succeed, remove the tx element.
    P.S. the element in tx_list is (MARK, cust, tokenNum), 
         when MARK is 1, the cust tries to buy, when MARK is -1, cust tries to sell
    '''
    waitingTx_Num_Old = len(tx_list)
    s = 0
    while s < len(tx_list):
        tx_mark = tx_list[s][0]
        tx_cust = tx_list[s][1]
        tx_tokenNum = tx_list[s][2]
        if tx_mark == - 1:
            # try sell
            if tx_cust.getExpectedPrice() < KennyCoin.getPrice():
                # cust sells successfully
                tx_cust.sell(tx_tokenNum)
                # change expectedPrice, means could do transaction again
                tx_cust.changeExpectedPrice(-1)
                sellNum = sellNum + 1
                tx_list.pop(s)
                s = s - 1
        else:
            # try buy
            if tx_cust.getExpectedPrice() >= KennyCoin.getPrice():
                # cust buys successfully
                tx_cust.buy(tx_tokenNum)
                # change expectedPrice, means could do transaction again
                tx_cust.changeExpectedPrice(-1)
                buyNum = buyNum + 1
                tx_list.pop(s)
                s = s - 1
        s = s + 1

    flag = 0
    if (j > 0) and (j % bouncingInterval == 0):
        # here assume the bouncing_mu is generated by random, range is determined by bouncing range
        Price_mu = random.uniform(0.1 * CurrentPrice, bouncingRange * CurrentPrice)
        # when Price_mu < than currentPrice, every one wants to sell, else every one wants to buy
        if Price_mu < CurrentPrice:
            flag = -1 # sell
        else:
            flag = 1 # buy
    else:
        Price_mu = CurrentPrice

    custExpectedPrice = np.random.normal(Price_mu, sigma, tx_round)
    i = 0
    for t in xrange(0,custNum):
        if i >= tx_round:
            break
        if custlist[t].getExpectedPrice() >= 0:
            continue
        if custExpectedPrice[i] > 0:
            # avoid newExpectedPrice <= 0
            # in fact newExpectedPrice should not be 0, otherwise will be dead buyer
            newExpectedPrice = custExpectedPrice[i]
        else:
            newExpectedPrice = 0.00001 * KennyCoin.getPrice()

        custlist[t].changeExpectedPrice(newExpectedPrice)
        if flag == -1:
            custSmartToken_Num = custlist[t].getownedSmartTokens()
            randomSell = random.randint(0,custSmartToken_Num)            
            if custlist[t].getExpectedPrice() < KennyCoin.getPrice():
                # cust sells successfully
                custlist[t].sell(randomSell)
                # change expectedPrice, means could do transaction again
                custlist[t].changeExpectedPrice(-1)
                sellNum = sellNum + 1
            else:
                # failed in selling, add cust to tx list, -1 means to sell
                tx_list.append((-1, custlist[t],randomSell))
                # BancorMarket.addSeller(custlist[t])

        elif flag == 1:
            custReserveToken_Num = custlist[t].getReserveTokens()
            randomBuy = random.randint(0, custReserveToken_Num)
            if custlist[t].getExpectedPrice() >= KennyCoin.getPrice():
                # cust buys successfully
                custlist[t].buy(randomBuy)
                custlist[t].changeExpectedPrice(-1)
                buyNum = buyNum + 1
            else:
                # failed in buying, add cust to tx list, 1 means to buy
                tx_list.append((1, custlist[t],randomBuy))
                # BancorMarket.addBuyer(custlist[t])

        else:
            '''
            Here customers choose buy and sell operation by throwing a coin, half-half probability 
            '''
            coin = random.randint(0, 100)
            if coin < 50:
                # buy
                custReserveToken_Num = custlist[t].getReserveTokens()
                randomBuy = random.randint(0, custReserveToken_Num)
                if custlist[t].getExpectedPrice() >= KennyCoin.getPrice():
                    # cust buy successfully
                    custlist[t].buy(randomBuy)
                    # change expectedPrice for cust, means he could do transaction again
                    custlist[t].changeExpectedPrice(-1)
                    buyNum = buyNum + 1
                else:
                    # failed in buying, add cust to tx list, 1 means to buy
                    tx_list.append((1, custlist[t],randomBuy))
                    # BancorMarket.addBuyer(custlist[t])
            else:
                # sell
                custSmartToken_Num = custlist[t].getownedSmartTokens()
                randomSell = random.randint(0,custSmartToken_Num)            
                if custlist[t].getExpectedPrice() < KennyCoin.getPrice():
                    # cust sells successfully
                    custlist[t].sell(randomSell)
                    # change expectedPrice for cust, means he could do transaction again
                    custlist[t].changeExpectedPrice(-1)
                    sellNum = sellNum + 1
                else:
                    # failed in selling, add cust to tx list, -1 means to sell
                    tx_list.append((-1, custlist[t],randomSell))
                    # BancorMarket.addSeller(custlist[t])
        i = i + 1
    # here we shuffle the cust list to let all customer to get oppotunity to make transactions
    random.shuffle(custlist)
    moneyBalance_all = 0
    for Joe in custlist:
        moneyBalance_all = moneyBalance_all + Joe.getmoneyBalance()

    moneyTracker.append((moneyBalance_all,j))
    failed_rateTracker.append((len(tx_list)/float(waitingTx_Num_Old+tx_round),j))
    waitingTracker.append((len(tx_list),j))
    PriceTracker.append((KennyCoin.getPrice(),j))

    print 'The',j,'round:', buyNum, 'buy tx |', sellNum, 'sell tx |', len(tx_list), 'unfinished tx.'
    fw.write('The '+str(j)+' round: '+str(buyNum)+' buy tx | '+str(sellNum)+' sell tx | '+str(len(tx_list))+' unfinished tx.\n')
    j = j + 1

# draw failure rate
j = 0
failedRate = []
myX_FR = []
while j < TimeRound:
    myX_FR.append(j)
    failedRate.append(failed_rateTracker[j][0])
    j = j + 1
x_FR = np.asarray(myX_FR)
y_FR = np.asarray(failedRate)
plt.plot(x_FR,y_FR,'o-',color = 'navy',alpha = 0.8)
plt.title('Failure Rate Change For All Rounds',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Failure Rate of Transaction', fontsize = 15)
plt.savefig('Figures/Coin-FailureRate.png', bbox_inches='tight')
plt.close()

# draw waiting list change
j = 0
waitingNum = []
myX_W = []
while j < TimeRound:
    myX_W.append(j)
    waitingNum.append(waitingTracker[j][0])
    j = j + 1
x_W = np.asarray(myX_W)
y_W = np.asarray(waitingNum)
plt.plot(x_W,y_W,'o-',color = 'navy',alpha = 0.8)
plt.title('Unfinished Transactions Num For All Rounds',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Unfinished Transactions Num', fontsize = 15)
plt.savefig('Figures/Coin-WaitingNum.png', bbox_inches='tight')
plt.close()

# draw price change figure
j = 0
PriceAllRound = []
myX_P = []
while j < TimeRound:
    PriceAllRound.append(PriceTracker[j][0])
    myX_P.append(j)
    j = j + 1
x_P = np.asarray(myX_P)
y_P = np.asarray(PriceAllRound)
plt.plot(x_P, y_P, 'o-',color = 'navy', alpha = 0.8)
plt.title('Price Change For All Round',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Price of Smart Token', fontsize = 15)
plt.savefig('Figures/Coin-Price_Change.png', bbox_inches='tight')
plt.close()

# draw money change figure
j = 0
moneyChange = []
myX_M = []
while j < TimeRound:
    moneyChange.append(moneyTracker[j][0])
    myX_M.append(j)
    j = j + 1
x_M = np.asarray(myX_M)
y_M = np.asarray(moneyChange)
plt.plot(x_M, y_M, 'o-', color = 'navy', alpha = 0.8)
plt.title('Money Balance Change For All Round',fontsize = 25)
plt.xlabel('Round #',fontsize = 15)
plt.ylabel('Money Balance of All Custs', fontsize = 15)
plt.savefig('Figures/Coin-MoneyBalance_Change.png', bbox_inches='tight')
plt.close()